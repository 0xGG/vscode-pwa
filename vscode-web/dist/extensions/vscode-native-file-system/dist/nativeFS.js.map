{"version":3,"sources":["webpack://vscode-native-file-system/webpack/universalModuleDefinition","webpack://vscode-native-file-system/./node_modules/nanoid/url-alphabet/index.js","webpack://vscode-native-file-system/./node_modules/nanoid/index.prod.js","webpack://vscode-native-file-system/./node_modules/path-browserify/index.js","webpack://vscode-native-file-system/./src/nativeFS.ts","webpack://vscode-native-file-system/webpack/bootstrap","webpack://vscode-native-file-system/webpack/runtime/define property getters","webpack://vscode-native-file-system/webpack/runtime/hasOwnProperty shorthand","webpack://vscode-native-file-system/webpack/runtime/make namespace object","webpack://vscode-native-file-system/webpack/startup"],"names":["root","factory","exports","module","define","amd","a","i","self","urlAlphabet","random","bytes","crypto","getRandomValues","Uint8Array","customRandom","alphabet","size","getRandom","mask","Math","log","length","LN2","step","id","j","customAlphabet","nanoid","byte","toString","toUpperCase","assertPath","path","TypeError","JSON","stringify","normalizeStringPosix","allowAboveRoot","code","res","lastSegmentLength","lastSlash","dots","charCodeAt","lastSlashIndex","lastIndexOf","slice","posix","resolve","cwd","resolvedPath","resolvedAbsolute","arguments","undefined","process","normalize","isAbsolute","trailingSeparator","join","joined","arg","relative","from","to","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","dirname","hasRoot","end","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","pathObject","sep","dir","base","name","_format","parse","ret","delimiter","win32","FileType","FileChangeType","FileNotFound","uri","Error","verifyPermission","fileHandle","mode","options","queryPermission","requestPermission","registered","product","nativeFS","NativeFS","commands","push","handler","directoryHandle","window","showDirectoryPicker","attachDirectory","stat","readDirectory","readFile","content","writeFile","oldUri","newUri","rename","delete","createDirectory","directoryHandleMap","rootDir","this","pathArr","replace","split","helper","getDirectoryHandle","getCurrentDirectoryStat","values","type","Directory","ctime","mtime","fHandle","getFileHandle","file","getFile","File","lastModified","error","result","entry","kind","Array","arrayBuffer","create","exists","overwrite","FileExists","events","Created","writable","createWritable","write","close","Changed","data","recursive","Deleted","removeEntry","scheme","authority","query","fragment","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","r","Symbol","toStringTag","value"],"mappings":"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","file":"nativeFS.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, function() {\nreturn ","// This alphabet uses `A-Za-z0-9_-` symbols. The genetic algorithm helped\n// optimize the gzip compression for this alphabet.\nlet urlAlphabet =\n  'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW'\n\nexport { urlAlphabet }\n","// This file replaces `index.js` in bundlers like webpack or Rollup,\n// according to `browser` config in `package.json`.\n\nimport { urlAlphabet } from './url-alphabet/index.js'\n\nif (false) {\n  // All bundlers will remove this block in the production bundle.\n  if (\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative' &&\n    typeof crypto === 'undefined'\n  ) {\n    throw new Error(\n      'React Native does not have a built-in secure random generator. ' +\n        'If you don’t need unpredictable IDs use `nanoid/non-secure`. ' +\n        'For secure IDs, import `react-native-get-random-values` ' +\n        'before Nano ID.'\n    )\n  }\n  if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {\n    throw new Error(\n      'Import file with `if (!window.crypto) window.crypto = window.msCrypto`' +\n        ' before importing Nano ID to fix IE 11 support'\n    )\n  }\n  if (typeof crypto === 'undefined') {\n    throw new Error(\n      'Your browser does not have secure random generator. ' +\n        'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'\n    )\n  }\n}\n\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\n\nlet customRandom = (alphabet, size, getRandom) => {\n  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes\n  // values closer to the alphabet size. The bitmask calculates the closest\n  // `2^31 - 1` number, which exceeds the alphabet size.\n  // For example, the bitmask for the alphabet size 30 is 31 (00011111).\n  // `Math.clz32` is not used, because it is not available in browsers.\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  // Though, the bitmask solution is not perfect since the bytes exceeding\n  // the alphabet size are refused. Therefore, to reliably generate the ID,\n  // the random bytes redundancy has to be satisfied.\n\n  // Note: every hardware random generator call is performance expensive,\n  // because the system call for entropy collection takes a lot of time.\n  // So, to avoid additional system calls, extra bytes are requested in advance.\n\n  // Next, a step determines how many random bytes to generate.\n  // The number of random bytes gets decided upon the ID size, mask,\n  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance\n  // according to benchmarks).\n\n  // `-~f => Math.ceil(f)` if f is a float\n  // `-~i => i + 1` if i is an integer\n  let step = -~((1.6 * mask * size) / alphabet.length)\n\n  return () => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      // A compact alternative for `for (var i = 0; i < step; i++)`.\n      let j = step\n      while (j--) {\n        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\n\nlet customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)\n\nlet nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n\n  // A compact alternative for `for (var i = 0; i < step; i++)`.\n  while (size--) {\n    // It is incorrect to use bytes exceeding the alphabet size.\n    // The following mask reduces the random byte in the 0-255 value\n    // range to the 0-63 value range. Therefore, adding hacks, such\n    // as empty string fallback or magic numbers, is unneccessary because\n    // the bitmask trims bytes down to the alphabet size.\n    let byte = bytes[size] & 63\n    if (byte < 36) {\n      // `0-9a-z`\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      // `A-Z`\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte < 63) {\n      id += '_'\n    } else {\n      id += '-'\n    }\n  }\n  return id\n}\n\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","/**\n * File System Provider for Native File System\n * Referred from https://github.com/microsoft/vscode-extension-samples/blob/main/fsprovider-sample/src/fileSystemProvider.ts\n */\n\nimport { nanoid } from \"nanoid\";\nimport * as path from \"path\";\n\n/** A few type from vscode */\nenum FileType {\n  /**\n   * The file type is unknown.\n   */\n  Unknown = 0,\n  /**\n   * A regular file.\n   */\n  File = 1,\n  /**\n   * A directory.\n   */\n  Directory = 2,\n  /**\n   * A symbolic link to a file.\n   */\n  SymbolicLink = 64,\n}\n\n/**\n * The `FileStat`-type represents metadata about a file\n */\nexport interface FileStat {\n  /**\n   * The type of the file, e.g. is a regular file, a directory, or symbolic link\n   * to a file.\n   *\n   * *Note:* This value might be a bitmask, e.g. `FileType.File | FileType.SymbolicLink`.\n   */\n  type: FileType;\n  /**\n   * The creation timestamp in milliseconds elapsed since January 1, 1970 00:00:00 UTC.\n   */\n  ctime: number;\n  /**\n   * The modification timestamp in milliseconds elapsed since January 1, 1970 00:00:00 UTC.\n   *\n   * *Note:* If the file changed, it is important to provide an updated `mtime` that advanced\n   * from the previous value. Otherwise there may be optimizations in place that will not show\n   * the updated file contents in an editor for example.\n   */\n  mtime: number;\n  /**\n   * The size in bytes.\n   *\n   * *Note:* If the file changed, it is important to provide an updated `size`. Otherwise there\n   * may be optimizations in place that will not show the updated file contents in an editor for\n   * example.\n   */\n  size: number;\n}\n\ninterface Uri {\n  scheme?: string;\n  path: string;\n  authority?: string;\n  query?: string;\n  fragment?: string;\n}\n\nfunction FileNotFound(uri: Uri) {\n  return new Error(`NativeFS FileNotFound ${uri.path}`);\n}\n\nfunction FileExists(uri: Uri) {\n  return new Error(`NativeFS FileExists ${uri.path}`);\n}\n\n/**\n * Enumeration of file change types.\n */\nenum FileChangeType {\n  /**\n   * The contents or metadata of a file have changed.\n   */\n  Changed = 1,\n\n  /**\n   * A file has been created.\n   */\n  Created = 2,\n\n  /**\n   * A file has been deleted.\n   */\n  Deleted = 3,\n}\n\n/**\n * The event filesystem providers must use to signal a file change.\n */\ninterface FileChangeEvent {\n  /**\n   * The type of change.\n   */\n  readonly type: FileChangeType;\n\n  /**\n   * The uri of the file that has changed.\n   */\n  readonly uri: Uri;\n}\n\nexport async function verifyPermission(\n  fileHandle: FileSystemHandle,\n  mode?: FileSystemPermissionMode\n) {\n  const options: FileSystemHandlePermissionDescriptor = {\n    mode,\n  };\n  if (!fileHandle) {\n    return false;\n  }\n  // Check if permission was already granted. If so, return true.\n  if ((await fileHandle.queryPermission(options)) === \"granted\") {\n    return true;\n  }\n\n  // Request permission. If the user grants permission, return true.\n  if ((await fileHandle.requestPermission(options)) === \"granted\") {\n    return true;\n  }\n  // The user didn't grant permission, so return false.\n  return false;\n}\n\nlet registered = false;\nexport function registerNativeFS(product: any) {\n  if (registered) {\n    return;\n  } else {\n    registered = true;\n  }\n  const nativeFS = new NativeFS();\n  const commands = product.commands || [];\n  commands.push(\n    {\n      id: \"nativeFS.showDirectoryPicker\",\n      handler: async () => {\n        const directoryHandle = await window.showDirectoryPicker();\n        const rootDir = nativeFS.attachDirectory(directoryHandle);\n        return rootDir;\n      },\n    },\n    {\n      id: \"nativeFS.stat\",\n      async handler(uri: Uri) {\n        return await nativeFS.stat(uri);\n      },\n    },\n    {\n      id: \"nativeFS.readDirectory\",\n      async handler(uri: Uri) {\n        return await nativeFS.readDirectory(uri);\n      },\n    },\n    {\n      id: \"nativeFS.readFile\",\n      async handler(uri: Uri) {\n        return await nativeFS.readFile(uri);\n      },\n    },\n    {\n      id: \"nativeFS.writeFile\",\n      async handler(\n        uri: Uri,\n        content: number[],\n        options: { create: boolean; overwrite: boolean }\n      ) {\n        return await nativeFS.writeFile(uri, content, options);\n      },\n    },\n    {\n      id: \"nativeFS.rename\",\n      async handler(oldUri: Uri, newUri: Uri, options: { overwrite: boolean }) {\n        return await nativeFS.rename(oldUri, newUri, options);\n      },\n    },\n    {\n      id: \"nativeFS.delete\",\n      async handler(uri: Uri, options: { recursive: boolean }) {\n        return await nativeFS.delete(uri, options);\n      },\n    },\n    {\n      id: \"nativeFS.createDirectory\",\n      async handler(uri: Uri) {\n        return await nativeFS.createDirectory(uri);\n      },\n    }\n  );\n}\n\nexport class NativeFS {\n  /**\n   * Its key is in format of /$RANDOM_ID/$DIRECTORY_NAME\n   */\n  private directoryHandleMap: { [key: string]: FileSystemDirectoryHandle } = {};\n\n  // --- attach local directory\n  public async attachDirectory(\n    directoryHandle: FileSystemDirectoryHandle\n  ): Promise<string> {\n    const rootDir = \"/\" + nanoid(8) + \"/\" + directoryHandle.name + \"/\";\n    this.directoryHandleMap[rootDir] = directoryHandle;\n    return rootDir;\n  }\n\n  public async helper(\n    path: string,\n    mode: FileSystemPermissionMode = \"readwrite\"\n  ): Promise<[FileSystemDirectoryHandle, string[]]> {\n    const pathArr = path.replace(/\\/+$/, \"\").split(\"/\");\n    const rootDir = \"/\" + pathArr[1] + \"/\" + pathArr[2] + \"/\";\n    const directoryHandle = this.directoryHandleMap[rootDir];\n    await verifyPermission(directoryHandle, mode);\n    return [directoryHandle, pathArr.slice(3, pathArr.length)];\n  }\n\n  // --- manage file metadata\n\n  public async stat(uri: Uri): Promise<FileStat> {\n    let [directoryHandle, pathArr] = await this.helper(uri.path, \"read\");\n    if (!directoryHandle) {\n      throw FileNotFound(uri);\n    }\n    let i = 0;\n    for (; i < pathArr.length - 1; i++) {\n      directoryHandle = await directoryHandle.getDirectoryHandle(pathArr[i]);\n    }\n\n    const getCurrentDirectoryStat = async () => {\n      let size = 0;\n      for await (const entry of directoryHandle.values()) {\n        size += 1;\n      }\n      const stat: FileStat = {\n        type: FileType.Directory,\n        ctime: 0, // This is now wrong\n        mtime: 0, // This is now wrong\n        size,\n      };\n      return stat;\n    };\n\n    if (!pathArr.length) {\n      return await getCurrentDirectoryStat();\n    }\n\n    // Check if it's file\n    try {\n      const fHandle = await directoryHandle.getFileHandle(pathArr[i]);\n      const file = await fHandle.getFile(); // https://w3c.github.io/FileAPI/#dfn-file\n      const stat: FileStat = {\n        type: FileType.File,\n        ctime: file.lastModified, // <= This is now wrong\n        mtime: file.lastModified,\n        size: file.size,\n      };\n      return stat;\n    } catch (error) {\n      // Check if it's directory\n      try {\n        const dHandle = await directoryHandle.getDirectoryHandle(pathArr[i]);\n        return await getCurrentDirectoryStat();\n      } catch (error) {\n        throw error;\n      }\n    }\n  }\n\n  public async readDirectory(uri: Uri): Promise<[string, FileType][]> {\n    let [directoryHandle, pathArr] = await this.helper(uri.path, \"read\");\n    if (!directoryHandle) {\n      throw FileNotFound(uri);\n    } else {\n      let i = 0;\n      for (; i < pathArr.length; i++) {\n        directoryHandle = await directoryHandle.getDirectoryHandle(pathArr[i]);\n      }\n      const result: [string, FileType][] = [];\n      for await (const entry of directoryHandle.values()) {\n        result.push([\n          entry.name,\n          entry.kind === \"directory\" ? FileType.Directory : FileType.File,\n        ]);\n      }\n      return result;\n    }\n  }\n\n  // --- manage file contents\n\n  public async readFile(uri: Uri): Promise<number[]> {\n    let [directoryHandle, pathArr] = await this.helper(uri.path, \"read\");\n    if (!directoryHandle) {\n      throw FileNotFound(uri);\n    } else {\n      let i = 0;\n      for (; i < pathArr.length - 1; i++) {\n        directoryHandle = await directoryHandle.getDirectoryHandle(pathArr[i]);\n      }\n      const file = await (\n        await directoryHandle.getFileHandle(pathArr[i])\n      ).getFile();\n      return Array.from(new Uint8Array(await file.arrayBuffer()));\n    }\n  }\n\n  public async writeFile(\n    uri: Uri,\n    content: number[],\n    options: { create: boolean; overwrite: boolean }\n  ): Promise<{ events: FileChangeEvent[] }> {\n    let [directoryHandle, pathArr] = await this.helper(uri.path, \"readwrite\");\n    if (!directoryHandle) {\n      throw FileNotFound(uri);\n    } else {\n      let i = 0;\n      for (; i < pathArr.length - 1; i++) {\n        directoryHandle = await directoryHandle.getDirectoryHandle(pathArr[i], {\n          create: options.create,\n        });\n      }\n\n      let exists = false;\n      for await (const entry of directoryHandle.values()) {\n        if (entry.name === pathArr[i]) {\n          exists = true;\n          break;\n        }\n      }\n      if (!exists && !options.create) {\n        throw FileNotFound(uri);\n      }\n      if (exists && options.create && !options.overwrite) {\n        throw FileExists(uri);\n      }\n\n      const fileHandle = await directoryHandle.getFileHandle(pathArr[i], {\n        create: options.create,\n      });\n      const events: FileChangeEvent[] = [];\n      if (!exists) {\n        events.push({ type: FileChangeType.Created, uri });\n      }\n      const writable = await fileHandle.createWritable();\n      await writable.write(Uint8Array.from(content));\n      await (writable as any).close();\n      events.push({ type: FileChangeType.Changed, uri });\n      return {\n        events,\n      };\n    }\n  }\n\n  // --- manage files/folders\n\n  public async rename(\n    oldUri: Uri,\n    newUri: Uri,\n    options: { overwrite: boolean }\n  ): Promise<{ events: FileChangeEvent[] }> {\n    const data = await this.readFile(oldUri);\n    await this.writeFile(newUri, data, {\n      create: true,\n      overwrite: options.overwrite,\n    });\n    await this.delete(oldUri, { recursive: true });\n    return {\n      events: [\n        { type: FileChangeType.Deleted, uri: oldUri },\n        { type: FileChangeType.Created, uri: newUri },\n      ],\n    };\n  }\n\n  public async delete(\n    uri: Uri,\n    options: { recursive: boolean }\n  ): Promise<{ events: FileChangeEvent[] }> {\n    let [directoryHandle, pathArr] = await this.helper(uri.path, \"readwrite\");\n    if (!directoryHandle) {\n      throw FileNotFound(uri);\n    }\n    let i = 0;\n    for (; i < pathArr.length - 1; i++) {\n      directoryHandle = await directoryHandle.getDirectoryHandle(pathArr[i]);\n    }\n    await directoryHandle.removeEntry(pathArr[i], {\n      recursive: options.recursive,\n    });\n    return {\n      events: [\n        // { type: vscode.FileChangeType.Changed, uri: dirname },\n        { uri, type: FileChangeType.Deleted },\n      ],\n    };\n  }\n\n  public async createDirectory(\n    uri: Uri\n  ): Promise<{ events: FileChangeEvent[] }> {\n    let [directoryHandle, pathArr] = await this.helper(uri.path, \"readwrite\");\n    if (!directoryHandle) {\n      throw FileNotFound(uri);\n    } else {\n      for (let i = 0; i < pathArr.length; i++) {\n        directoryHandle = await directoryHandle.getDirectoryHandle(pathArr[i], {\n          create: true,\n        });\n      }\n    }\n    const dirname: Uri = {\n      scheme: \"nativefs\",\n      path: path.posix.dirname(uri.path),\n      authority: \"\",\n      query: \"\",\n      fragment: \"\",\n    };\n\n    return {\n      events: [\n        { type: FileChangeType.Changed, uri: dirname },\n        { type: FileChangeType.Created, uri },\n      ],\n    };\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(348);\n"],"sourceRoot":""}