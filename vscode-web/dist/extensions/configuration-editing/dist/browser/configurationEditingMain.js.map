{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/configurationEditingMain.ts","webpack:///./node_modules/jsonc-parser/lib/esm/main.js","webpack:///./node_modules/jsonc-parser/lib/esm/impl/format.js","webpack:///./node_modules/jsonc-parser/lib/esm/impl/scanner.js","webpack:///./node_modules/jsonc-parser/lib/esm/impl/edit.js","webpack:///./node_modules/jsonc-parser/lib/esm/impl/parser.js","webpack:///external \"vscode\"","webpack:////home/runner/work/vscode-web/vscode-web/vscode/build/polyfills/vscode-nls.js","webpack:///./src/settingsDocumentHelper.ts","webpack:///./src/extensionsProposals.ts"],"names":[],"mappings":"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B;AACvC;AACA;AACA;AACO,yBAAyB,+DAAyB;AACzD;AACA;AACA;AACO,uBAAuB,6DAAuB;AACrD;AACA;AACA;AACO,kBAAkB,wDAAkB;AAC3C;AACA;AACA;AACO,mBAAmB,yDAAmB;AAC7C;AACA;AACA;AACO,YAAY,kDAAY;AAC/B;AACA;AACA;AACA;AACA;AACO,oBAAoB,0DAAoB;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,mDAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,sDAAgB;AAC3B;AACA;AACA;AACA;AACO;AACP,kCAAkC,QAAQ;AAC1C,eAAe,oDAAc;AAC7B;AACA;AACA;;;;;;;;ACnHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACa;AAC6B;AACnC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sEAAsE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;ACjMA;AAAA;AAAA;AACA;AACA;AACA;AACa;AACb;AACA;AACA;AACA;AACO;AACP,kCAAkC,sBAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kCAAkC,YAAY,EAAE;AAChD;AACA,+BAA+B,cAAc,EAAE;AAC/C,oCAAoC,cAAc,EAAE;AACpD,qCAAqC,oBAAoB,EAAE;AAC3D,qCAAqC,0BAA0B,EAAE;AACjE,wCAAwC,wBAAwB,EAAE;AAClE,6CAA6C,+CAA+C,EAAE;AAC9F,oCAAoC,kBAAkB,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1WA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACa;AAC4B;AACgB;AAClD;AACP;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,yDAAS;AACxB;AACA;AACA;AACA;AACA,iBAAiB,kEAAkB;AACnC;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,qCAAqC,iGAAiG;AACtI;AACA;AACA,uBAAuB,kEAAkB;AACzC;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oEAAoE;AACjH;AACA;AACA;AACA,6CAA6C,mFAAmF;AAChI;AACA;AACA;AACA,mCAAmC;AACnC,0BAA0B;AAC1B;AACA;AACA,gGAAgG,4BAA4B,EAAE;AAC9H;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,6BAA6B,qDAAK;AAClC;AACA;AACA,wCAAwC,qDAAK;AAC7C;AACA;AACA;AACA,gBAAgB,sDAAM,WAAW,qCAAqC;AACtE;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4EAA4E;AACzF;AACO;AACP;AACA;AACO;AACP;AACA;;;;;;;;ACvKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACa;AAC6B;AAC1C;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACO;AACP,sBAAsB;AACtB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2CAA2C;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,4BAA4B,aAAa;AACzC,6BAA6B,gCAAgC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,+CAA+C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,4BAA4B,aAAa;AACzC,6BAA6B,gCAAgC;AAC7D,yBAAyB,0EAA0E;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kFAAkF;AACvH,SAAS;AACT;AACA,qCAAqC,oFAAoF;AACzH,yCAAyC,qFAAqF;AAC9H,SAAS;AACT;AACA,oDAAoD;AACpD;AACA;AACA;AACA,SAAS;AACT;AACA,qCAAqC,iFAAiF;AACtH,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qBAAqB,gGAAgG;AACrH;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,yBAAyB,+CAA+C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uCAAuC,2BAA2B;AAClE;AACA;AACA;AACA;AACA;AACO;AACP,uCAAuC,2BAA2B;AAClE;AACA;AACA;AACA,2BAA2B,qDAAqD;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,6BAA6B,gCAAgC;AAC7D,mBAAmB,8DAAa;AAChC;AACA,4CAA4C,6IAA6I,EAAE,gBAAgB,aAAa;AACxN;AACA;AACA,+CAA+C,kJAAkJ,EAAE,gBAAgB,aAAa;AAChO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qBAAqB;AAC7D,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mBAAmB,8DAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjnBA,mC;;;;;;;ACAA;AACA;AACA;AACA;;AAEa;AACb,8CAA8C,cAAc;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AACvE;AACA;AACA;AACA;AACA;AACA,CAAC,mEAAmE;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC9EA;;;gGAGgG;;;AAEhG,sCAAiC;AACjC,8CAA4D;AAC5D,mCAAkC;AAClC,qDAA2E;AAE3E,MAAM,QAAQ,GAAG,GAAG,CAAC,iBAAiB,EAAE,CAAC;AAEzC,MAAa,gBAAgB;IAE5B,YAAoB,QAA6B;QAA7B,aAAQ,GAAR,QAAQ,CAAqB;IAAI,CAAC;IAE/C,sBAAsB,CAAC,QAAyB,EAAE,MAAgC;QACxF,MAAM,QAAQ,GAAG,0BAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,EAAE,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC;QACxF,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,sBAAsB,CAAC,QAAQ,CAAC,IAAI,IAAI,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,QA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","file":"configurationEditingMain.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getLocation, JSONPath, parse, visit } from 'jsonc-parser';\nimport * as vscode from 'vscode';\nimport * as nls from 'vscode-nls';\nimport { SettingsDocument } from './settingsDocumentHelper';\nimport { provideInstalledExtensionProposals } from './extensionsProposals';\nconst localize = nls.loadMessageBundle();\n\nexport function activate(context: vscode.ExtensionContext): void {\n\t//settings.json suggestions\n\tcontext.subscriptions.push(registerSettingsCompletions());\n\n\t//extensions suggestions\n\tcontext.subscriptions.push(...registerExtensionsCompletions());\n\n\t// launch.json variable suggestions\n\tcontext.subscriptions.push(registerVariableCompletions('**/launch.json'));\n\n\t// task.json variable suggestions\n\tcontext.subscriptions.push(registerVariableCompletions('**/tasks.json'));\n\n\t// keybindings.json/package.json context key suggestions\n\tcontext.subscriptions.push(registerContextKeyCompletions());\n}\n\nfunction registerSettingsCompletions(): vscode.Disposable {\n\treturn vscode.languages.registerCompletionItemProvider({ language: 'jsonc', pattern: '**/settings.json' }, {\n\t\tprovideCompletionItems(document, position, token) {\n\t\t\treturn new SettingsDocument(document).provideCompletionItems(position, token);\n\t\t}\n\t});\n}\n\nfunction registerVariableCompletions(pattern: string): vscode.Disposable {\n\treturn vscode.languages.registerCompletionItemProvider({ language: 'jsonc', pattern }, {\n\t\tprovideCompletionItems(document, position, _token) {\n\t\t\tconst location = getLocation(document.getText(), document.offsetAt(position));\n\t\t\tif (!location.isAtPropertyKey && location.previousNode && location.previousNode.type === 'string') {\n\t\t\t\tconst indexOf$ = document.lineAt(position.line).text.indexOf('$');\n\t\t\t\tconst startPosition = indexOf$ >= 0 ? new vscode.Position(position.line, indexOf$) : position;\n\n\t\t\t\treturn [\n\t\t\t\t\t{ label: 'workspaceFolder', detail: localize('workspaceFolder', \"The path of the folder opened in VS Code\") },\n\t\t\t\t\t{ label: 'workspaceFolderBasename', detail: localize('workspaceFolderBasename', \"The name of the folder opened in VS Code without any slashes (/)\") },\n\t\t\t\t\t{ label: 'relativeFile', detail: localize('relativeFile', \"The current opened file relative to ${workspaceFolder}\") },\n\t\t\t\t\t{ label: 'relativeFileDirname', detail: localize('relativeFileDirname', \"The current opened file's dirname relative to ${workspaceFolder}\") },\n\t\t\t\t\t{ label: 'file', detail: localize('file', \"The current opened file\") },\n\t\t\t\t\t{ label: 'cwd', detail: localize('cwd', \"The task runner's current working directory on startup\") },\n\t\t\t\t\t{ label: 'lineNumber', detail: localize('lineNumber', \"The current selected line number in the active file\") },\n\t\t\t\t\t{ label: 'selectedText', detail: localize('selectedText', \"The current selected text in the active file\") },\n\t\t\t\t\t{ label: 'fileDirname', detail: localize('fileDirname', \"The current opened file's dirname\") },\n\t\t\t\t\t{ label: 'fileExtname', detail: localize('fileExtname', \"The current opened file's extension\") },\n\t\t\t\t\t{ label: 'fileBasename', detail: localize('fileBasename', \"The current opened file's basename\") },\n\t\t\t\t\t{ label: 'fileBasenameNoExtension', detail: localize('fileBasenameNoExtension', \"The current opened file's basename with no file extension\") },\n\t\t\t\t\t{ label: 'defaultBuildTask', detail: localize('defaultBuildTask', \"The name of the default build task. If there is not a single default build task then a quick pick is shown to choose the build task.\") },\n\t\t\t\t].map(variable => ({\n\t\t\t\t\tlabel: '${' + variable.label + '}',\n\t\t\t\t\trange: new vscode.Range(startPosition, position),\n\t\t\t\t\tdetail: variable.detail\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\treturn [];\n\t\t}\n\t});\n}\n\ninterface IExtensionsContent {\n\trecommendations: string[];\n}\n\nfunction registerExtensionsCompletions(): vscode.Disposable[] {\n\treturn [registerExtensionsCompletionsInExtensionsDocument(), registerExtensionsCompletionsInWorkspaceConfigurationDocument()];\n}\n\nfunction registerExtensionsCompletionsInExtensionsDocument(): vscode.Disposable {\n\treturn vscode.languages.registerCompletionItemProvider({ pattern: '**/extensions.json' }, {\n\t\tprovideCompletionItems(document, position, _token) {\n\t\t\tconst location = getLocation(document.getText(), document.offsetAt(position));\n\t\t\tconst range = document.getWordRangeAtPosition(position) || new vscode.Range(position, position);\n\t\t\tif (location.path[0] === 'recommendations') {\n\t\t\t\tconst extensionsContent = <IExtensionsContent>parse(document.getText());\n\t\t\t\treturn provideInstalledExtensionProposals(extensionsContent && extensionsContent.recommendations || [], '', range, false);\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\t});\n}\n\nfunction registerExtensionsCompletionsInWorkspaceConfigurationDocument(): vscode.Disposable {\n\treturn vscode.languages.registerCompletionItemProvider({ pattern: '**/*.code-workspace' }, {\n\t\tprovideCompletionItems(document, position, _token) {\n\t\t\tconst location = getLocation(document.getText(), document.offsetAt(position));\n\t\t\tconst range = document.getWordRangeAtPosition(position) || new vscode.Range(position, position);\n\t\t\tif (location.path[0] === 'extensions' && location.path[1] === 'recommendations') {\n\t\t\t\tconst extensionsContent = <IExtensionsContent>parse(document.getText())['extensions'];\n\t\t\t\treturn provideInstalledExtensionProposals(extensionsContent && extensionsContent.recommendations || [], '', range, false);\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\t});\n}\n\nvscode.languages.registerDocumentSymbolProvider({ pattern: '**/launch.json', language: 'jsonc' }, {\n\tprovideDocumentSymbols(document: vscode.TextDocument, _token: vscode.CancellationToken): vscode.ProviderResult<vscode.SymbolInformation[]> {\n\t\tconst result: vscode.SymbolInformation[] = [];\n\t\tlet name: string = '';\n\t\tlet lastProperty = '';\n\t\tlet startOffset = 0;\n\t\tlet depthInObjects = 0;\n\n\t\tvisit(document.getText(), {\n\t\t\tonObjectProperty: (property, _offset, _length) => {\n\t\t\t\tlastProperty = property;\n\t\t\t},\n\t\t\tonLiteralValue: (value: any, _offset: number, _length: number) => {\n\t\t\t\tif (lastProperty === 'name') {\n\t\t\t\t\tname = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonObjectBegin: (offset: number, _length: number) => {\n\t\t\t\tdepthInObjects++;\n\t\t\t\tif (depthInObjects === 2) {\n\t\t\t\t\tstartOffset = offset;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonObjectEnd: (offset: number, _length: number) => {\n\t\t\t\tif (name && depthInObjects === 2) {\n\t\t\t\t\tresult.push(new vscode.SymbolInformation(name, vscode.SymbolKind.Object, new vscode.Range(document.positionAt(startOffset), document.positionAt(offset))));\n\t\t\t\t}\n\t\t\t\tdepthInObjects--;\n\t\t\t},\n\t\t});\n\n\t\treturn result;\n\t}\n}, { label: 'Launch Targets' });\n\nfunction registerContextKeyCompletions(): vscode.Disposable {\n\ttype ContextKeyInfo = { key: string, type?: string, description?: string };\n\n\tconst paths = new Map<vscode.DocumentFilter, JSONPath[]>([\n\t\t[{ language: 'jsonc', pattern: '**/keybindings.json' }, [\n\t\t\t['*', 'when']\n\t\t]],\n\t\t[{ language: 'json', pattern: '**/package.json' }, [\n\t\t\t['contributes', 'menus', '*', '*', 'when'],\n\t\t\t['contributes', 'views', '*', '*', 'when'],\n\t\t\t['contributes', 'viewsWelcome', '*', 'when'],\n\t\t\t['contributes', 'keybindings', '*', 'when'],\n\t\t\t['contributes', 'keybindings', 'when'],\n\t\t]]\n\t]);\n\n\treturn vscode.languages.registerCompletionItemProvider(\n\t\t[...paths.keys()],\n\t\t{\n\t\t\tasync provideCompletionItems(document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken) {\n\n\t\t\t\tconst location = getLocation(document.getText(), document.offsetAt(position));\n\n\t\t\t\tif (location.isAtPropertyKey) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet isValidLocation = false;\n\t\t\t\tfor (const [key, value] of paths) {\n\t\t\t\t\tif (vscode.languages.match(key, document)) {\n\t\t\t\t\t\tif (value.some(location.matches.bind(location))) {\n\t\t\t\t\t\t\tisValidLocation = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!isValidLocation) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// for JSON everything with quotes is a word\n\t\t\t\tconst jsonWord = document.getWordRangeAtPosition(position);\n\t\t\t\tif (!jsonWord || jsonWord.start.isEqual(position) || jsonWord.end.isEqual(position)) {\n\t\t\t\t\t// we aren't inside a \"JSON word\" or on its quotes\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet replacing: vscode.Range | undefined;\n\t\t\t\tif (jsonWord.end.character - jsonWord.start.character === 2 || document.getWordRangeAtPosition(position, /\\s+/)) {\n\t\t\t\t\t// empty json word or on whitespace\n\t\t\t\t\treplacing = new vscode.Range(position, position);\n\t\t\t\t} else {\n\t\t\t\t\treplacing = document.getWordRangeAtPosition(position, /[a-zA-Z.]+/);\n\t\t\t\t}\n\n\t\t\t\tif (!replacing) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst inserting = replacing.with(undefined, position);\n\n\t\t\t\tconst data = await vscode.commands.executeCommand<ContextKeyInfo[]>('getContextKeyInfo');\n\t\t\t\tif (token.isCancellationRequested || !data) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst result = new vscode.CompletionList();\n\t\t\t\tfor (const item of data) {\n\t\t\t\t\tconst completion = new vscode.CompletionItem(item.key, vscode.CompletionItemKind.Constant);\n\t\t\t\t\tcompletion.detail = item.type;\n\t\t\t\t\tcompletion.range = { replacing, inserting };\n\t\t\t\t\tcompletion.documentation = item.description;\n\t\t\t\t\tresult.items.push(completion);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport * as formatter from './impl/format';\nimport * as edit from './impl/edit';\nimport * as scanner from './impl/scanner';\nimport * as parser from './impl/parser';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport var createScanner = scanner.createScanner;\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport var getLocation = parser.getLocation;\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore, always check the errors list to find out if the input was valid.\n */\nexport var parse = parser.parse;\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport var parseTree = parser.parseTree;\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport var findNodeAtLocation = parser.findNodeAtLocation;\n/**\n * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport var findNodeAtOffset = parser.findNodeAtOffset;\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport var getNodePath = parser.getNodePath;\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport var getNodeValue = parser.getNodeValue;\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport var visit = parser.visit;\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport var stripComments = parser.stripComments;\nexport function printParseErrorCode(code) {\n    switch (code) {\n        case 1 /* InvalidSymbol */: return 'InvalidSymbol';\n        case 2 /* InvalidNumberFormat */: return 'InvalidNumberFormat';\n        case 3 /* PropertyNameExpected */: return 'PropertyNameExpected';\n        case 4 /* ValueExpected */: return 'ValueExpected';\n        case 5 /* ColonExpected */: return 'ColonExpected';\n        case 6 /* CommaExpected */: return 'CommaExpected';\n        case 7 /* CloseBraceExpected */: return 'CloseBraceExpected';\n        case 8 /* CloseBracketExpected */: return 'CloseBracketExpected';\n        case 9 /* EndOfFileExpected */: return 'EndOfFileExpected';\n        case 10 /* InvalidCommentToken */: return 'InvalidCommentToken';\n        case 11 /* UnexpectedEndOfComment */: return 'UnexpectedEndOfComment';\n        case 12 /* UnexpectedEndOfString */: return 'UnexpectedEndOfString';\n        case 13 /* UnexpectedEndOfNumber */: return 'UnexpectedEndOfNumber';\n        case 14 /* InvalidUnicode */: return 'InvalidUnicode';\n        case 15 /* InvalidEscapeCharacter */: return 'InvalidEscapeCharacter';\n        case 16 /* InvalidCharacter */: return 'InvalidCharacter';\n    }\n    return '<unknown ParseErrorCode>';\n}\n/**\n * Computes the edits needed to format a JSON document.\n *\n * @param documentText The input text\n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\nexport function format(documentText, range, options) {\n    return formatter.format(documentText, range, options);\n}\n/**\n * Computes the edits needed to modify a value in the JSON document.\n *\n * @param documentText The input text\n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created.\n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\nexport function modify(text, path, value, options) {\n    return edit.setProperty(text, path, value, options.formattingOptions, options.getInsertionIndex);\n}\n/**\n * Applies edits to a input string.\n */\nexport function applyEdits(text, edits) {\n    for (var i = edits.length - 1; i >= 0; i--) {\n        text = edit.applyEdit(text, edits[i]);\n    }\n    return text;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { createScanner } from './scanner';\nexport function format(documentText, range, options) {\n    var initialIndentLevel;\n    var formatText;\n    var formatTextStart;\n    var rangeStart;\n    var rangeEnd;\n    if (range) {\n        rangeStart = range.offset;\n        rangeEnd = rangeStart + range.length;\n        formatTextStart = rangeStart;\n        while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {\n            formatTextStart--;\n        }\n        var endOffset = rangeEnd;\n        while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {\n            endOffset++;\n        }\n        formatText = documentText.substring(formatTextStart, endOffset);\n        initialIndentLevel = computeIndentLevel(formatText, options);\n    }\n    else {\n        formatText = documentText;\n        initialIndentLevel = 0;\n        formatTextStart = 0;\n        rangeStart = 0;\n        rangeEnd = documentText.length;\n    }\n    var eol = getEOL(options, documentText);\n    var lineBreak = false;\n    var indentLevel = 0;\n    var indentValue;\n    if (options.insertSpaces) {\n        indentValue = repeat(' ', options.tabSize || 4);\n    }\n    else {\n        indentValue = '\\t';\n    }\n    var scanner = createScanner(formatText, false);\n    var hasError = false;\n    function newLineAndIndent() {\n        return eol + repeat(indentValue, initialIndentLevel + indentLevel);\n    }\n    function scanNext() {\n        var token = scanner.scan();\n        lineBreak = false;\n        while (token === 15 /* Trivia */ || token === 14 /* LineBreakTrivia */) {\n            lineBreak = lineBreak || (token === 14 /* LineBreakTrivia */);\n            token = scanner.scan();\n        }\n        hasError = token === 16 /* Unknown */ || scanner.getTokenError() !== 0 /* None */;\n        return token;\n    }\n    var editOperations = [];\n    function addEdit(text, startOffset, endOffset) {\n        if (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {\n            editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });\n        }\n    }\n    var firstToken = scanNext();\n    if (firstToken !== 17 /* EOF */) {\n        var firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n        var initialIndent = repeat(indentValue, initialIndentLevel);\n        addEdit(initialIndent, formatTextStart, firstTokenStart);\n    }\n    while (firstToken !== 17 /* EOF */) {\n        var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n        var secondToken = scanNext();\n        var replaceContent = '';\n        while (!lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {\n            // comments on the same line: keep them on the same line, but ignore them otherwise\n            var commentTokenStart = scanner.getTokenOffset() + formatTextStart;\n            addEdit(' ', firstTokenEnd, commentTokenStart);\n            firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n            replaceContent = secondToken === 12 /* LineCommentTrivia */ ? newLineAndIndent() : '';\n            secondToken = scanNext();\n        }\n        if (secondToken === 2 /* CloseBraceToken */) {\n            if (firstToken !== 1 /* OpenBraceToken */) {\n                indentLevel--;\n                replaceContent = newLineAndIndent();\n            }\n        }\n        else if (secondToken === 4 /* CloseBracketToken */) {\n            if (firstToken !== 3 /* OpenBracketToken */) {\n                indentLevel--;\n                replaceContent = newLineAndIndent();\n            }\n        }\n        else {\n            switch (firstToken) {\n                case 3 /* OpenBracketToken */:\n                case 1 /* OpenBraceToken */:\n                    indentLevel++;\n                    replaceContent = newLineAndIndent();\n                    break;\n                case 5 /* CommaToken */:\n                case 12 /* LineCommentTrivia */:\n                    replaceContent = newLineAndIndent();\n                    break;\n                case 13 /* BlockCommentTrivia */:\n                    if (lineBreak) {\n                        replaceContent = newLineAndIndent();\n                    }\n                    else {\n                        // symbol following comment on the same line: keep on same line, separate with ' '\n                        replaceContent = ' ';\n                    }\n                    break;\n                case 6 /* ColonToken */:\n                    replaceContent = ' ';\n                    break;\n                case 10 /* StringLiteral */:\n                    if (secondToken === 6 /* ColonToken */) {\n                        replaceContent = '';\n                        break;\n                    }\n                // fall through\n                case 7 /* NullKeyword */:\n                case 8 /* TrueKeyword */:\n                case 9 /* FalseKeyword */:\n                case 11 /* NumericLiteral */:\n                case 2 /* CloseBraceToken */:\n                case 4 /* CloseBracketToken */:\n                    if (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */) {\n                        replaceContent = ' ';\n                    }\n                    else if (secondToken !== 5 /* CommaToken */ && secondToken !== 17 /* EOF */) {\n                        hasError = true;\n                    }\n                    break;\n                case 16 /* Unknown */:\n                    hasError = true;\n                    break;\n            }\n            if (lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {\n                replaceContent = newLineAndIndent();\n            }\n        }\n        var secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n        addEdit(replaceContent, firstTokenEnd, secondTokenStart);\n        firstToken = secondToken;\n    }\n    return editOperations;\n}\nfunction repeat(s, count) {\n    var result = '';\n    for (var i = 0; i < count; i++) {\n        result += s;\n    }\n    return result;\n}\nfunction computeIndentLevel(content, options) {\n    var i = 0;\n    var nChars = 0;\n    var tabSize = options.tabSize || 4;\n    while (i < content.length) {\n        var ch = content.charAt(i);\n        if (ch === ' ') {\n            nChars++;\n        }\n        else if (ch === '\\t') {\n            nChars += tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    return Math.floor(nChars / tabSize);\n}\nfunction getEOL(options, text) {\n    for (var i = 0; i < text.length; i++) {\n        var ch = text.charAt(i);\n        if (ch === '\\r') {\n            if (i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                return '\\r\\n';\n            }\n            return '\\r';\n        }\n        else if (ch === '\\n') {\n            return '\\n';\n        }\n    }\n    return (options && options.eol) || '\\n';\n}\nexport function isEOL(text, offset) {\n    return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport function createScanner(text, ignoreTrivia) {\n    if (ignoreTrivia === void 0) { ignoreTrivia = false; }\n    var len = text.length;\n    var pos = 0, value = '', tokenOffset = 0, token = 16 /* Unknown */, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0 /* None */;\n    function scanHexDigits(count, exact) {\n        var digits = 0;\n        var value = 0;\n        while (digits < count || !exact) {\n            var ch = text.charCodeAt(pos);\n            if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {\n                value = value * 16 + ch - 48 /* _0 */;\n            }\n            else if (ch >= 65 /* A */ && ch <= 70 /* F */) {\n                value = value * 16 + ch - 65 /* A */ + 10;\n            }\n            else if (ch >= 97 /* a */ && ch <= 102 /* f */) {\n                value = value * 16 + ch - 97 /* a */ + 10;\n            }\n            else {\n                break;\n            }\n            pos++;\n            digits++;\n        }\n        if (digits < count) {\n            value = -1;\n        }\n        return value;\n    }\n    function setPosition(newPosition) {\n        pos = newPosition;\n        value = '';\n        tokenOffset = 0;\n        token = 16 /* Unknown */;\n        scanError = 0 /* None */;\n    }\n    function scanNumber() {\n        var start = pos;\n        if (text.charCodeAt(pos) === 48 /* _0 */) {\n            pos++;\n        }\n        else {\n            pos++;\n            while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n            }\n        }\n        if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {\n            pos++;\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n            }\n            else {\n                scanError = 3 /* UnexpectedEndOfNumber */;\n                return text.substring(start, pos);\n            }\n        }\n        var end = pos;\n        if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {\n            pos++;\n            if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {\n                pos++;\n            }\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n                end = pos;\n            }\n            else {\n                scanError = 3 /* UnexpectedEndOfNumber */;\n            }\n        }\n        return text.substring(start, end);\n    }\n    function scanString() {\n        var result = '', start = pos;\n        while (true) {\n            if (pos >= len) {\n                result += text.substring(start, pos);\n                scanError = 2 /* UnexpectedEndOfString */;\n                break;\n            }\n            var ch = text.charCodeAt(pos);\n            if (ch === 34 /* doubleQuote */) {\n                result += text.substring(start, pos);\n                pos++;\n                break;\n            }\n            if (ch === 92 /* backslash */) {\n                result += text.substring(start, pos);\n                pos++;\n                if (pos >= len) {\n                    scanError = 2 /* UnexpectedEndOfString */;\n                    break;\n                }\n                var ch2 = text.charCodeAt(pos++);\n                switch (ch2) {\n                    case 34 /* doubleQuote */:\n                        result += '\\\"';\n                        break;\n                    case 92 /* backslash */:\n                        result += '\\\\';\n                        break;\n                    case 47 /* slash */:\n                        result += '/';\n                        break;\n                    case 98 /* b */:\n                        result += '\\b';\n                        break;\n                    case 102 /* f */:\n                        result += '\\f';\n                        break;\n                    case 110 /* n */:\n                        result += '\\n';\n                        break;\n                    case 114 /* r */:\n                        result += '\\r';\n                        break;\n                    case 116 /* t */:\n                        result += '\\t';\n                        break;\n                    case 117 /* u */:\n                        var ch3 = scanHexDigits(4, true);\n                        if (ch3 >= 0) {\n                            result += String.fromCharCode(ch3);\n                        }\n                        else {\n                            scanError = 4 /* InvalidUnicode */;\n                        }\n                        break;\n                    default:\n                        scanError = 5 /* InvalidEscapeCharacter */;\n                }\n                start = pos;\n                continue;\n            }\n            if (ch >= 0 && ch <= 0x1f) {\n                if (isLineBreak(ch)) {\n                    result += text.substring(start, pos);\n                    scanError = 2 /* UnexpectedEndOfString */;\n                    break;\n                }\n                else {\n                    scanError = 6 /* InvalidCharacter */;\n                    // mark as error but continue with string\n                }\n            }\n            pos++;\n        }\n        return result;\n    }\n    function scanNext() {\n        value = '';\n        scanError = 0 /* None */;\n        tokenOffset = pos;\n        lineStartOffset = lineNumber;\n        prevTokenLineStartOffset = tokenLineStartOffset;\n        if (pos >= len) {\n            // at the end\n            tokenOffset = len;\n            return token = 17 /* EOF */;\n        }\n        var code = text.charCodeAt(pos);\n        // trivia: whitespace\n        if (isWhiteSpace(code)) {\n            do {\n                pos++;\n                value += String.fromCharCode(code);\n                code = text.charCodeAt(pos);\n            } while (isWhiteSpace(code));\n            return token = 15 /* Trivia */;\n        }\n        // trivia: newlines\n        if (isLineBreak(code)) {\n            pos++;\n            value += String.fromCharCode(code);\n            if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {\n                pos++;\n                value += '\\n';\n            }\n            lineNumber++;\n            tokenLineStartOffset = pos;\n            return token = 14 /* LineBreakTrivia */;\n        }\n        switch (code) {\n            // tokens: []{}:,\n            case 123 /* openBrace */:\n                pos++;\n                return token = 1 /* OpenBraceToken */;\n            case 125 /* closeBrace */:\n                pos++;\n                return token = 2 /* CloseBraceToken */;\n            case 91 /* openBracket */:\n                pos++;\n                return token = 3 /* OpenBracketToken */;\n            case 93 /* closeBracket */:\n                pos++;\n                return token = 4 /* CloseBracketToken */;\n            case 58 /* colon */:\n                pos++;\n                return token = 6 /* ColonToken */;\n            case 44 /* comma */:\n                pos++;\n                return token = 5 /* CommaToken */;\n            // strings\n            case 34 /* doubleQuote */:\n                pos++;\n                value = scanString();\n                return token = 10 /* StringLiteral */;\n            // comments\n            case 47 /* slash */:\n                var start = pos - 1;\n                // Single-line comment\n                if (text.charCodeAt(pos + 1) === 47 /* slash */) {\n                    pos += 2;\n                    while (pos < len) {\n                        if (isLineBreak(text.charCodeAt(pos))) {\n                            break;\n                        }\n                        pos++;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 12 /* LineCommentTrivia */;\n                }\n                // Multi-line comment\n                if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {\n                    pos += 2;\n                    var safeLength = len - 1; // For lookahead.\n                    var commentClosed = false;\n                    while (pos < safeLength) {\n                        var ch = text.charCodeAt(pos);\n                        if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {\n                            pos += 2;\n                            commentClosed = true;\n                            break;\n                        }\n                        pos++;\n                        if (isLineBreak(ch)) {\n                            if (ch === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {\n                                pos++;\n                            }\n                            lineNumber++;\n                            tokenLineStartOffset = pos;\n                        }\n                    }\n                    if (!commentClosed) {\n                        pos++;\n                        scanError = 1 /* UnexpectedEndOfComment */;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 13 /* BlockCommentTrivia */;\n                }\n                // just a single slash\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 /* Unknown */;\n            // numbers\n            case 45 /* minus */:\n                value += String.fromCharCode(code);\n                pos++;\n                if (pos === len || !isDigit(text.charCodeAt(pos))) {\n                    return token = 16 /* Unknown */;\n                }\n            // found a minus, followed by a number so\n            // we fall through to proceed with scanning\n            // numbers\n            case 48 /* _0 */:\n            case 49 /* _1 */:\n            case 50 /* _2 */:\n            case 51 /* _3 */:\n            case 52 /* _4 */:\n            case 53 /* _5 */:\n            case 54 /* _6 */:\n            case 55 /* _7 */:\n            case 56 /* _8 */:\n            case 57 /* _9 */:\n                value += scanNumber();\n                return token = 11 /* NumericLiteral */;\n            // literals and unknown symbols\n            default:\n                // is a literal? Read the full word.\n                while (pos < len && isUnknownContentCharacter(code)) {\n                    pos++;\n                    code = text.charCodeAt(pos);\n                }\n                if (tokenOffset !== pos) {\n                    value = text.substring(tokenOffset, pos);\n                    // keywords: true, false, null\n                    switch (value) {\n                        case 'true': return token = 8 /* TrueKeyword */;\n                        case 'false': return token = 9 /* FalseKeyword */;\n                        case 'null': return token = 7 /* NullKeyword */;\n                    }\n                    return token = 16 /* Unknown */;\n                }\n                // some\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 /* Unknown */;\n        }\n    }\n    function isUnknownContentCharacter(code) {\n        if (isWhiteSpace(code) || isLineBreak(code)) {\n            return false;\n        }\n        switch (code) {\n            case 125 /* closeBrace */:\n            case 93 /* closeBracket */:\n            case 123 /* openBrace */:\n            case 91 /* openBracket */:\n            case 34 /* doubleQuote */:\n            case 58 /* colon */:\n            case 44 /* comma */:\n            case 47 /* slash */:\n                return false;\n        }\n        return true;\n    }\n    function scanNextNonTrivia() {\n        var result;\n        do {\n            result = scanNext();\n        } while (result >= 12 /* LineCommentTrivia */ && result <= 15 /* Trivia */);\n        return result;\n    }\n    return {\n        setPosition: setPosition,\n        getPosition: function () { return pos; },\n        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n        getToken: function () { return token; },\n        getTokenValue: function () { return value; },\n        getTokenOffset: function () { return tokenOffset; },\n        getTokenLength: function () { return pos - tokenOffset; },\n        getTokenStartLine: function () { return lineStartOffset; },\n        getTokenStartCharacter: function () { return tokenOffset - prevTokenLineStartOffset; },\n        getTokenError: function () { return scanError; },\n    };\n}\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||\n        ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||\n        ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;\n}\nfunction isLineBreak(ch) {\n    return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;\n}\nfunction isDigit(ch) {\n    return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { format, isEOL } from './format';\nimport { parseTree, findNodeAtLocation } from './parser';\nexport function removeProperty(text, path, formattingOptions) {\n    return setProperty(text, path, void 0, formattingOptions);\n}\nexport function setProperty(text, originalPath, value, formattingOptions, getInsertionIndex) {\n    var _a;\n    var path = originalPath.slice();\n    var errors = [];\n    var root = parseTree(text, errors);\n    var parent = void 0;\n    var lastSegment = void 0;\n    while (path.length > 0) {\n        lastSegment = path.pop();\n        parent = findNodeAtLocation(root, path);\n        if (parent === void 0 && value !== void 0) {\n            if (typeof lastSegment === 'string') {\n                value = (_a = {}, _a[lastSegment] = value, _a);\n            }\n            else {\n                value = [value];\n            }\n        }\n        else {\n            break;\n        }\n    }\n    if (!parent) {\n        // empty document\n        if (value === void 0) { // delete\n            throw new Error('Can not delete in empty document');\n        }\n        return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, formattingOptions);\n    }\n    else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n        var existing = findNodeAtLocation(parent, [lastSegment]);\n        if (existing !== void 0) {\n            if (value === void 0) { // delete\n                if (!existing.parent) {\n                    throw new Error('Malformed AST');\n                }\n                var propertyIndex = parent.children.indexOf(existing.parent);\n                var removeBegin = void 0;\n                var removeEnd = existing.parent.offset + existing.parent.length;\n                if (propertyIndex > 0) {\n                    // remove the comma of the previous node\n                    var previous = parent.children[propertyIndex - 1];\n                    removeBegin = previous.offset + previous.length;\n                }\n                else {\n                    removeBegin = parent.offset + 1;\n                    if (parent.children.length > 1) {\n                        // remove the comma of the next node\n                        var next = parent.children[1];\n                        removeEnd = next.offset;\n                    }\n                }\n                return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, formattingOptions);\n            }\n            else {\n                // set value of existing property\n                return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, formattingOptions);\n            }\n        }\n        else {\n            if (value === void 0) { // delete\n                return []; // property does not exist, nothing to do\n            }\n            var newProperty = JSON.stringify(lastSegment) + \": \" + JSON.stringify(value);\n            var index = getInsertionIndex ? getInsertionIndex(parent.children.map(function (p) { return p.children[0].value; })) : parent.children.length;\n            var edit = void 0;\n            if (index > 0) {\n                var previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            else if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };\n            }\n            return withFormatting(text, edit, formattingOptions);\n        }\n    }\n    else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n        var insertIndex = lastSegment;\n        if (insertIndex === -1) {\n            // Insert\n            var newProperty = \"\" + JSON.stringify(value);\n            var edit = void 0;\n            if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                var previous = parent.children[parent.children.length - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, formattingOptions);\n        }\n        else {\n            if (value === void 0 && parent.children.length >= 0) {\n                //Removal\n                var removalIndex = lastSegment;\n                var toRemove = parent.children[removalIndex];\n                var edit = void 0;\n                if (parent.children.length === 1) {\n                    // only item\n                    edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };\n                }\n                else if (parent.children.length - 1 === removalIndex) {\n                    // last item\n                    var previous = parent.children[removalIndex - 1];\n                    var offset = previous.offset + previous.length;\n                    var parentEndOffset = parent.offset + parent.length;\n                    edit = { offset: offset, length: parentEndOffset - 2 - offset, content: '' };\n                }\n                else {\n                    edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };\n                }\n                return withFormatting(text, edit, formattingOptions);\n            }\n            else {\n                throw new Error('Array modification not supported yet');\n            }\n        }\n    }\n    else {\n        throw new Error(\"Can not add \" + (typeof lastSegment !== 'number' ? 'index' : 'property') + \" to parent of type \" + parent.type);\n    }\n}\nfunction withFormatting(text, edit, formattingOptions) {\n    // apply the edit\n    var newText = applyEdit(text, edit);\n    // format the new text\n    var begin = edit.offset;\n    var end = edit.offset + edit.content.length;\n    if (edit.length === 0 || edit.content.length === 0) { // insert or remove\n        while (begin > 0 && !isEOL(newText, begin - 1)) {\n            begin--;\n        }\n        while (end < newText.length && !isEOL(newText, end)) {\n            end++;\n        }\n    }\n    var edits = format(newText, { offset: begin, length: end - begin }, formattingOptions);\n    // apply the formatting edits and track the begin and end offsets of the changes\n    for (var i = edits.length - 1; i >= 0; i--) {\n        var edit_1 = edits[i];\n        newText = applyEdit(newText, edit_1);\n        begin = Math.min(begin, edit_1.offset);\n        end = Math.max(end, edit_1.offset + edit_1.length);\n        end += edit_1.content.length - edit_1.length;\n    }\n    // create a single edit with all changes\n    var editLength = text.length - (newText.length - end) - begin;\n    return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];\n}\nexport function applyEdit(text, edit) {\n    return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nexport function isWS(text, offset) {\n    return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { createScanner } from './scanner';\nvar ParseOptions;\n(function (ParseOptions) {\n    ParseOptions.DEFAULT = {\n        allowTrailingComma: false\n    };\n})(ParseOptions || (ParseOptions = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text, position) {\n    var segments = []; // strings or numbers\n    var earlyReturnException = new Object();\n    var previousNode = undefined;\n    var previousNodeInst = {\n        value: {},\n        offset: 0,\n        length: 0,\n        type: 'object',\n        parent: undefined\n    };\n    var isAtPropertyKey = false;\n    function setPreviousNode(value, offset, length, type) {\n        previousNodeInst.value = value;\n        previousNodeInst.offset = offset;\n        previousNodeInst.length = length;\n        previousNodeInst.type = type;\n        previousNodeInst.colonOffset = undefined;\n        previousNode = previousNodeInst;\n    }\n    try {\n        visit(text, {\n            onObjectBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                isAtPropertyKey = position > offset;\n                segments.push(''); // push a placeholder (will be replaced)\n            },\n            onObjectProperty: function (name, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(name, offset, length, 'property');\n                segments[segments.length - 1] = name;\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onObjectEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onArrayBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.push(0);\n            },\n            onArrayEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onLiteralValue: function (value, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(value, offset, length, getNodeType(value));\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onSeparator: function (sep, offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                if (sep === ':' && previousNode && previousNode.type === 'property') {\n                    previousNode.colonOffset = offset;\n                    isAtPropertyKey = false;\n                    previousNode = undefined;\n                }\n                else if (sep === ',') {\n                    var last = segments[segments.length - 1];\n                    if (typeof last === 'number') {\n                        segments[segments.length - 1] = last + 1;\n                    }\n                    else {\n                        isAtPropertyKey = true;\n                        segments[segments.length - 1] = '';\n                    }\n                    previousNode = undefined;\n                }\n            }\n        });\n    }\n    catch (e) {\n        if (e !== earlyReturnException) {\n            throw e;\n        }\n    }\n    return {\n        path: segments,\n        previousNode: previousNode,\n        isAtPropertyKey: isAtPropertyKey,\n        matches: function (pattern) {\n            var k = 0;\n            for (var i = 0; k < pattern.length && i < segments.length; i++) {\n                if (pattern[k] === segments[i] || pattern[k] === '*') {\n                    k++;\n                }\n                else if (pattern[k] !== '**') {\n                    return false;\n                }\n            }\n            return k === pattern.length;\n        }\n    };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentProperty = null;\n    var currentParent = [];\n    var previousParents = [];\n    function onValue(value) {\n        if (Array.isArray(currentParent)) {\n            currentParent.push(value);\n        }\n        else if (currentProperty !== null) {\n            currentParent[currentProperty] = value;\n        }\n    }\n    var visitor = {\n        onObjectBegin: function () {\n            var object = {};\n            onValue(object);\n            previousParents.push(currentParent);\n            currentParent = object;\n            currentProperty = null;\n        },\n        onObjectProperty: function (name) {\n            currentProperty = name;\n        },\n        onObjectEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onArrayBegin: function () {\n            var array = [];\n            onValue(array);\n            previousParents.push(currentParent);\n            currentParent = array;\n            currentProperty = null;\n        },\n        onArrayEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onLiteralValue: onValue,\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n    function ensurePropertyComplete(endOffset) {\n        if (currentParent.type === 'property') {\n            currentParent.length = endOffset - currentParent.offset;\n            currentParent = currentParent.parent;\n        }\n    }\n    function onValue(valueNode) {\n        currentParent.children.push(valueNode);\n        return valueNode;\n    }\n    var visitor = {\n        onObjectBegin: function (offset) {\n            currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onObjectProperty: function (name, offset, length) {\n            currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });\n            currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });\n        },\n        onObjectEnd: function (offset, length) {\n            ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onArrayBegin: function (offset, length) {\n            currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onArrayEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onLiteralValue: function (value, offset, length) {\n            onValue({ type: getNodeType(value), offset: offset, length: length, parent: currentParent, value: value });\n            ensurePropertyComplete(offset + length);\n        },\n        onSeparator: function (sep, offset, length) {\n            if (currentParent.type === 'property') {\n                if (sep === ':') {\n                    currentParent.colonOffset = offset;\n                }\n                else if (sep === ',') {\n                    ensurePropertyComplete(offset);\n                }\n            }\n        },\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    var result = currentParent.children[0];\n    if (result) {\n        delete result.parent;\n    }\n    return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root, path) {\n    if (!root) {\n        return undefined;\n    }\n    var node = root;\n    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n        var segment = path_1[_i];\n        if (typeof segment === 'string') {\n            if (node.type !== 'object' || !Array.isArray(node.children)) {\n                return undefined;\n            }\n            var found = false;\n            for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n                var propertyNode = _b[_a];\n                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n                    node = propertyNode.children[1];\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return undefined;\n            }\n        }\n        else {\n            var index = segment;\n            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                return undefined;\n            }\n            node = node.children[index];\n        }\n    }\n    return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport function getNodePath(node) {\n    if (!node.parent || !node.parent.children) {\n        return [];\n    }\n    var path = getNodePath(node.parent);\n    if (node.parent.type === 'property') {\n        var key = node.parent.children[0].value;\n        path.push(key);\n    }\n    else if (node.parent.type === 'array') {\n        var index = node.parent.children.indexOf(node);\n        if (index !== -1) {\n            path.push(index);\n        }\n    }\n    return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport function getNodeValue(node) {\n    switch (node.type) {\n        case 'array':\n            return node.children.map(getNodeValue);\n        case 'object':\n            var obj = Object.create(null);\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                var prop = _a[_i];\n                var valueNode = prop.children[1];\n                if (valueNode) {\n                    obj[prop.children[0].value] = getNodeValue(valueNode);\n                }\n            }\n            return obj;\n        case 'null':\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return node.value;\n        default:\n            return undefined;\n    }\n}\nexport function contains(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport function findNodeAtOffset(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    if (contains(node, offset, includeRightBound)) {\n        var children = node.children;\n        if (Array.isArray(children)) {\n            for (var i = 0; i < children.length && children[i].offset <= offset; i++) {\n                var item = findNodeAtOffset(children[i], offset, includeRightBound);\n                if (item) {\n                    return item;\n                }\n            }\n        }\n        return node;\n    }\n    return undefined;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text, visitor, options) {\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var _scanner = createScanner(text, false);\n    function toNoArgVisit(visitFunction) {\n        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n    }\n    function toOneArgVisit(visitFunction) {\n        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n    }\n    var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n    var disallowComments = options && options.disallowComments;\n    var allowTrailingComma = options && options.allowTrailingComma;\n    function scanNext() {\n        while (true) {\n            var token = _scanner.scan();\n            switch (_scanner.getTokenError()) {\n                case 4 /* InvalidUnicode */:\n                    handleError(14 /* InvalidUnicode */);\n                    break;\n                case 5 /* InvalidEscapeCharacter */:\n                    handleError(15 /* InvalidEscapeCharacter */);\n                    break;\n                case 3 /* UnexpectedEndOfNumber */:\n                    handleError(13 /* UnexpectedEndOfNumber */);\n                    break;\n                case 1 /* UnexpectedEndOfComment */:\n                    if (!disallowComments) {\n                        handleError(11 /* UnexpectedEndOfComment */);\n                    }\n                    break;\n                case 2 /* UnexpectedEndOfString */:\n                    handleError(12 /* UnexpectedEndOfString */);\n                    break;\n                case 6 /* InvalidCharacter */:\n                    handleError(16 /* InvalidCharacter */);\n                    break;\n            }\n            switch (token) {\n                case 12 /* LineCommentTrivia */:\n                case 13 /* BlockCommentTrivia */:\n                    if (disallowComments) {\n                        handleError(10 /* InvalidCommentToken */);\n                    }\n                    else {\n                        onComment();\n                    }\n                    break;\n                case 16 /* Unknown */:\n                    handleError(1 /* InvalidSymbol */);\n                    break;\n                case 15 /* Trivia */:\n                case 14 /* LineBreakTrivia */:\n                    break;\n                default:\n                    return token;\n            }\n        }\n    }\n    function handleError(error, skipUntilAfter, skipUntil) {\n        if (skipUntilAfter === void 0) { skipUntilAfter = []; }\n        if (skipUntil === void 0) { skipUntil = []; }\n        onError(error);\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            var token = _scanner.getToken();\n            while (token !== 17 /* EOF */) {\n                if (skipUntilAfter.indexOf(token) !== -1) {\n                    scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token) !== -1) {\n                    break;\n                }\n                token = scanNext();\n            }\n        }\n    }\n    function parseString(isValue) {\n        var value = _scanner.getTokenValue();\n        if (isValue) {\n            onLiteralValue(value);\n        }\n        else {\n            onObjectProperty(value);\n        }\n        scanNext();\n        return true;\n    }\n    function parseLiteral() {\n        switch (_scanner.getToken()) {\n            case 11 /* NumericLiteral */:\n                var value = 0;\n                try {\n                    value = JSON.parse(_scanner.getTokenValue());\n                    if (typeof value !== 'number') {\n                        handleError(2 /* InvalidNumberFormat */);\n                        value = 0;\n                    }\n                }\n                catch (e) {\n                    handleError(2 /* InvalidNumberFormat */);\n                }\n                onLiteralValue(value);\n                break;\n            case 7 /* NullKeyword */:\n                onLiteralValue(null);\n                break;\n            case 8 /* TrueKeyword */:\n                onLiteralValue(true);\n                break;\n            case 9 /* FalseKeyword */:\n                onLiteralValue(false);\n                break;\n            default:\n                return false;\n        }\n        scanNext();\n        return true;\n    }\n    function parseProperty() {\n        if (_scanner.getToken() !== 10 /* StringLiteral */) {\n            handleError(3 /* PropertyNameExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            return false;\n        }\n        parseString(false);\n        if (_scanner.getToken() === 6 /* ColonToken */) {\n            onSeparator(':');\n            scanNext(); // consume colon\n            if (!parseValue()) {\n                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n        }\n        else {\n            handleError(5 /* ColonExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n        }\n        return true;\n    }\n    function parseObject() {\n        onObjectBegin();\n        scanNext(); // consume open brace\n        var needsComma = false;\n        while (_scanner.getToken() !== 2 /* CloseBraceToken */ && _scanner.getToken() !== 17 /* EOF */) {\n            if (_scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 2 /* CloseBraceToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* CommaExpected */, [], []);\n            }\n            if (!parseProperty()) {\n                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onObjectEnd();\n        if (_scanner.getToken() !== 2 /* CloseBraceToken */) {\n            handleError(7 /* CloseBraceExpected */, [2 /* CloseBraceToken */], []);\n        }\n        else {\n            scanNext(); // consume close brace\n        }\n        return true;\n    }\n    function parseArray() {\n        onArrayBegin();\n        scanNext(); // consume open bracket\n        var needsComma = false;\n        while (_scanner.getToken() !== 4 /* CloseBracketToken */ && _scanner.getToken() !== 17 /* EOF */) {\n            if (_scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 4 /* CloseBracketToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* CommaExpected */, [], []);\n            }\n            if (!parseValue()) {\n                handleError(4 /* ValueExpected */, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onArrayEnd();\n        if (_scanner.getToken() !== 4 /* CloseBracketToken */) {\n            handleError(8 /* CloseBracketExpected */, [4 /* CloseBracketToken */], []);\n        }\n        else {\n            scanNext(); // consume close bracket\n        }\n        return true;\n    }\n    function parseValue() {\n        switch (_scanner.getToken()) {\n            case 3 /* OpenBracketToken */:\n                return parseArray();\n            case 1 /* OpenBraceToken */:\n                return parseObject();\n            case 10 /* StringLiteral */:\n                return parseString(true);\n            default:\n                return parseLiteral();\n        }\n    }\n    scanNext();\n    if (_scanner.getToken() === 17 /* EOF */) {\n        if (options.allowEmptyContent) {\n            return true;\n        }\n        handleError(4 /* ValueExpected */, [], []);\n        return false;\n    }\n    if (!parseValue()) {\n        handleError(4 /* ValueExpected */, [], []);\n        return false;\n    }\n    if (_scanner.getToken() !== 17 /* EOF */) {\n        handleError(9 /* EndOfFileExpected */, [], []);\n    }\n    return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport function stripComments(text, replaceCh) {\n    var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;\n    do {\n        pos = _scanner.getPosition();\n        kind = _scanner.scan();\n        switch (kind) {\n            case 12 /* LineCommentTrivia */:\n            case 13 /* BlockCommentTrivia */:\n            case 17 /* EOF */:\n                if (offset !== pos) {\n                    parts.push(text.substring(offset, pos));\n                }\n                if (replaceCh !== undefined) {\n                    parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                }\n                offset = _scanner.getPosition();\n                break;\n        }\n    } while (kind !== 17 /* EOF */);\n    return parts.join('');\n}\nexport function getNodeType(value) {\n    switch (typeof value) {\n        case 'boolean': return 'boolean';\n        case 'number': return 'number';\n        case 'string': return 'string';\n        case 'object': {\n            if (!value) {\n                return 'null';\n            }\n            else if (Array.isArray(value)) {\n                return 'array';\n            }\n            return 'object';\n        }\n        default: return 'null';\n    }\n}\n","module.exports = require(\"vscode\");","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nfunction format(message, args) {\n\tlet result;\n\t// if (isPseudo) {\n\t// \t// FF3B and FF3D is the Unicode zenkaku representation for [ and ]\n\t// \tmessage = '\\uFF3B' + message.replace(/[aouei]/g, '$&$&') + '\\uFF3D';\n\t// }\n\tif (args.length === 0) {\n\t\tresult = message;\n\t}\n\telse {\n\t\tresult = message.replace(/\\{(\\d+)\\}/g, function (match, rest) {\n\t\t\tlet index = rest[0];\n\t\t\tlet arg = args[index];\n\t\t\tlet replacement = match;\n\t\t\tif (typeof arg === 'string') {\n\t\t\t\treplacement = arg;\n\t\t\t}\n\t\t\telse if (typeof arg === 'number' || typeof arg === 'boolean' || arg === void 0 || arg === null) {\n\t\t\t\treplacement = String(arg);\n\t\t\t}\n\t\t\treturn replacement;\n\t\t});\n\t}\n\treturn result;\n}\n\nfunction localize(key, message) {\n\tlet args = [];\n\tfor (let _i = 2; _i < arguments.length; _i++) {\n\t\targs[_i - 2] = arguments[_i];\n\t}\n\treturn format(message, args);\n}\n\nfunction loadMessageBundle(file) {\n\treturn localize;\n}\n\nlet MessageFormat;\n(function (MessageFormat) {\n\tMessageFormat[\"file\"] = \"file\";\n\tMessageFormat[\"bundle\"] = \"bundle\";\n\tMessageFormat[\"both\"] = \"both\";\n})(MessageFormat = exports.MessageFormat || (exports.MessageFormat = {}));\nlet BundleFormat;\n(function (BundleFormat) {\n\t// the nls.bundle format\n\tBundleFormat[\"standalone\"] = \"standalone\";\n\tBundleFormat[\"languagePack\"] = \"languagePack\";\n})(BundleFormat = exports.BundleFormat || (exports.BundleFormat = {}));\n\nexports.loadMessageBundle = loadMessageBundle;\nfunction config(opts) {\n\tif (opts) {\n\t\tif (isString(opts.locale)) {\n\t\t\toptions.locale = opts.locale.toLowerCase();\n\t\t\toptions.language = options.locale;\n\t\t\tresolvedLanguage = undefined;\n\t\t\tresolvedBundles = Object.create(null);\n\t\t}\n\t\tif (opts.messageFormat !== undefined) {\n\t\t\toptions.messageFormat = opts.messageFormat;\n\t\t}\n\t\tif (opts.bundleFormat === BundleFormat.standalone && options.languagePackSupport === true) {\n\t\t\toptions.languagePackSupport = false;\n\t\t}\n\t}\n\tisPseudo = options.locale === 'pseudo';\n\treturn loadMessageBundle;\n}\nexports.config = config;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as vscode from 'vscode';\nimport { getLocation, Location, parse } from 'jsonc-parser';\nimport * as nls from 'vscode-nls';\nimport { provideInstalledExtensionProposals } from './extensionsProposals';\n\nconst localize = nls.loadMessageBundle();\n\nexport class SettingsDocument {\n\n\tconstructor(private document: vscode.TextDocument) { }\n\n\tpublic provideCompletionItems(position: vscode.Position, _token: vscode.CancellationToken): vscode.ProviderResult<vscode.CompletionItem[] | vscode.CompletionList> {\n\t\tconst location = getLocation(this.document.getText(), this.document.offsetAt(position));\n\t\tconst range = this.document.getWordRangeAtPosition(position) || new vscode.Range(position, position);\n\n\t\t// window.title\n\t\tif (location.path[0] === 'window.title') {\n\t\t\treturn this.provideWindowTitleCompletionItems(location, range);\n\t\t}\n\n\t\t// files.association\n\t\tif (location.path[0] === 'files.associations') {\n\t\t\treturn this.provideFilesAssociationsCompletionItems(location, range);\n\t\t}\n\n\t\t// files.exclude, search.exclude\n\t\tif (location.path[0] === 'files.exclude' || location.path[0] === 'search.exclude') {\n\t\t\treturn this.provideExcludeCompletionItems(location, range);\n\t\t}\n\n\t\t// files.defaultLanguage\n\t\tif (location.path[0] === 'files.defaultLanguage') {\n\t\t\treturn this.provideLanguageCompletionItems(location, range).then(items => {\n\n\t\t\t\t// Add special item '${activeEditorLanguage}'\n\t\t\t\treturn [this.newSimpleCompletionItem(JSON.stringify('${activeEditorLanguage}'), range, localize('activeEditor', \"Use the language of the currently active text editor if any\")), ...items];\n\t\t\t});\n\t\t}\n\n\t\t// settingsSync.ignoredExtensions\n\t\tif (location.path[0] === 'settingsSync.ignoredExtensions') {\n\t\t\tlet ignoredExtensions = [];\n\t\t\ttry {\n\t\t\t\tignoredExtensions = parse(this.document.getText())['settingsSync.ignoredExtensions'];\n\t\t\t} catch (e) {/* ignore error */ }\n\t\t\treturn provideInstalledExtensionProposals(ignoredExtensions, '', range, true);\n\t\t}\n\n\t\t// remote.extensionKind\n\t\tif (location.path[0] === 'remote.extensionKind' && location.path.length === 2 && location.isAtPropertyKey) {\n\t\t\tlet alreadyConfigured: string[] = [];\n\t\t\ttry {\n\t\t\t\talreadyConfigured = Object.keys(parse(this.document.getText())['remote.extensionKind']);\n\t\t\t} catch (e) {/* ignore error */ }\n\t\t\treturn provideInstalledExtensionProposals(alreadyConfigured, `: [\\n\\t\"ui\"\\n]`, range, true);\n\t\t}\n\n\t\treturn this.provideLanguageOverridesCompletionItems(location, position);\n\t}\n\n\tprivate provideWindowTitleCompletionItems(_location: Location, range: vscode.Range): vscode.ProviderResult<vscode.CompletionItem[]> {\n\t\tconst completions: vscode.CompletionItem[] = [];\n\n\t\tcompletions.push(this.newSimpleCompletionItem('${activeEditorShort}', range, localize('activeEditorShort', \"the file name (e.g. myFile.txt)\")));\n\t\tcompletions.push(this.newSimpleCompletionItem('${activeEditorMedium}', range, localize('activeEditorMedium', \"the path of the file relative to the workspace folder (e.g. myFolder/myFileFolder/myFile.txt)\")));\n\t\tcompletions.push(this.newSimpleCompletionItem('${activeEditorLong}', range, localize('activeEditorLong', \"the full path of the file (e.g. /Users/Development/myFolder/myFileFolder/myFile.txt)\")));\n\t\tcompletions.push(this.newSimpleCompletionItem('${activeFolderShort}', range, localize('activeFolderShort', \"the name of the folder the file is contained in (e.g. myFileFolder)\")));\n\t\tcompletions.push(this.newSimpleCompletionItem('${activeFolderMedium}', range, localize('activeFolderMedium', \"the path of the folder the file is contained in, relative to the workspace folder (e.g. myFolder/myFileFolder)\")));\n\t\tcompletions.push(this.newSimpleCompletionItem('${activeFolderLong}', range, localize('activeFolderLong', \"the full path of the folder the file is contained in (e.g. /Users/Development/myFolder/myFileFolder)\")));\n\t\tcompletions.push(this.newSimpleCompletionItem('${rootName}', range, localize('rootName', \"name of the workspace (e.g. myFolder or myWorkspace)\")));\n\t\tcompletions.push(this.newSimpleCompletionItem('${rootPath}', range, localize('rootPath', \"file path of the workspace (e.g. /Users/Development/myWorkspace)\")));\n\t\tcompletions.push(this.newSimpleCompletionItem('${folderName}', range, localize('folderName', \"name of the workspace folder the file is contained in (e.g. myFolder)\")));\n\t\tcompletions.push(this.newSimpleCompletionItem('${folderPath}', range, localize('folderPath', \"file path of the workspace folder the file is contained in (e.g. /Users/Development/myFolder)\")));\n\t\tcompletions.push(this.newSimpleCompletionItem('${appName}', range, localize('appName', \"e.g. VS Code\")));\n\t\tcompletions.push(this.newSimpleCompletionItem('${remoteName}', range, localize('remoteName', \"e.g. SSH\")));\n\t\tcompletions.push(this.newSimpleCompletionItem('${dirty}', range, localize('dirty', \"a dirty indicator if the active editor is dirty\")));\n\t\tcompletions.push(this.newSimpleCompletionItem('${separator}', range, localize('separator', \"a conditional separator (' - ') that only shows when surrounded by variables with values\")));\n\n\t\treturn Promise.resolve(completions);\n\t}\n\n\tprivate provideFilesAssociationsCompletionItems(location: Location, range: vscode.Range): vscode.ProviderResult<vscode.CompletionItem[]> {\n\t\tconst completions: vscode.CompletionItem[] = [];\n\n\t\tif (location.path.length === 2) {\n\t\t\t// Key\n\t\t\tif (!location.isAtPropertyKey || location.path[1] === '') {\n\t\t\t\tcompletions.push(this.newSnippetCompletionItem({\n\t\t\t\t\tlabel: localize('assocLabelFile', \"Files with Extension\"),\n\t\t\t\t\tdocumentation: localize('assocDescriptionFile', \"Map all files matching the glob pattern in their filename to the language with the given identifier.\"),\n\t\t\t\t\tsnippet: location.isAtPropertyKey ? '\"*.${1:extension}\": \"${2:language}\"' : '{ \"*.${1:extension}\": \"${2:language}\" }',\n\t\t\t\t\trange\n\t\t\t\t}));\n\n\t\t\t\tcompletions.push(this.newSnippetCompletionItem({\n\t\t\t\t\tlabel: localize('assocLabelPath', \"Files with Path\"),\n\t\t\t\t\tdocumentation: localize('assocDescriptionPath', \"Map all files matching the absolute path glob pattern in their path to the language with the given identifier.\"),\n\t\t\t\t\tsnippet: location.isAtPropertyKey ? '\"/${1:path to file}/*.${2:extension}\": \"${3:language}\"' : '{ \"/${1:path to file}/*.${2:extension}\": \"${3:language}\" }',\n\t\t\t\t\trange\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\t// Value\n\t\t\t\treturn this.provideLanguageCompletionItemsForLanguageOverrides(location, range);\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.resolve(completions);\n\t}\n\n\tprivate provideExcludeCompletionItems(location: Location, range: vscode.Range): vscode.ProviderResult<vscode.CompletionItem[]> {\n\t\tconst completions: vscode.CompletionItem[] = [];\n\n\t\t// Key\n\t\tif (location.path.length === 1) {\n\t\t\tcompletions.push(this.newSnippetCompletionItem({\n\t\t\t\tlabel: localize('fileLabel', \"Files by Extension\"),\n\t\t\t\tdocumentation: localize('fileDescription', \"Match all files of a specific file extension.\"),\n\t\t\t\tsnippet: location.isAtPropertyKey ? '\"**/*.${1:extension}\": true' : '{ \"**/*.${1:extension}\": true }',\n\t\t\t\trange\n\t\t\t}));\n\n\t\t\tcompletions.push(this.newSnippetCompletionItem({\n\t\t\t\tlabel: localize('filesLabel', \"Files with Multiple Extensions\"),\n\t\t\t\tdocumentation: localize('filesDescription', \"Match all files with any of the file extensions.\"),\n\t\t\t\tsnippet: location.isAtPropertyKey ? '\"**/*.{ext1,ext2,ext3}\": true' : '{ \"**/*.{ext1,ext2,ext3}\": true }',\n\t\t\t\trange\n\t\t\t}));\n\n\t\t\tcompletions.push(this.newSnippetCompletionItem({\n\t\t\t\tlabel: localize('derivedLabel', \"Files with Siblings by Name\"),\n\t\t\t\tdocumentation: localize('derivedDescription', \"Match files that have siblings with the same name but a different extension.\"),\n\t\t\t\tsnippet: location.isAtPropertyKey ? '\"**/*.${1:source-extension}\": { \"when\": \"$(basename).${2:target-extension}\" }' : '{ \"**/*.${1:source-extension}\": { \"when\": \"$(basename).${2:target-extension}\" } }',\n\t\t\t\trange\n\t\t\t}));\n\n\t\t\tcompletions.push(this.newSnippetCompletionItem({\n\t\t\t\tlabel: localize('topFolderLabel', \"Folder by Name (Top Level)\"),\n\t\t\t\tdocumentation: localize('topFolderDescription', \"Match a top level folder with a specific name.\"),\n\t\t\t\tsnippet: location.isAtPropertyKey ? '\"${1:name}\": true' : '{ \"${1:name}\": true }',\n\t\t\t\trange\n\t\t\t}));\n\n\t\t\tcompletions.push(this.newSnippetCompletionItem({\n\t\t\t\tlabel: localize('topFoldersLabel', \"Folders with Multiple Names (Top Level)\"),\n\t\t\t\tdocumentation: localize('topFoldersDescription', \"Match multiple top level folders.\"),\n\t\t\t\tsnippet: location.isAtPropertyKey ? '\"{folder1,folder2,folder3}\": true' : '{ \"{folder1,folder2,folder3}\": true }',\n\t\t\t\trange\n\t\t\t}));\n\n\t\t\tcompletions.push(this.newSnippetCompletionItem({\n\t\t\t\tlabel: localize('folderLabel', \"Folder by Name (Any Location)\"),\n\t\t\t\tdocumentation: localize('folderDescription', \"Match a folder with a specific name in any location.\"),\n\t\t\t\tsnippet: location.isAtPropertyKey ? '\"**/${1:name}\": true' : '{ \"**/${1:name}\": true }',\n\t\t\t\trange\n\t\t\t}));\n\t\t}\n\n\t\t// Value\n\t\telse {\n\t\t\tcompletions.push(this.newSimpleCompletionItem('false', range, localize('falseDescription', \"Disable the pattern.\")));\n\t\t\tcompletions.push(this.newSimpleCompletionItem('true', range, localize('trueDescription', \"Enable the pattern.\")));\n\n\t\t\tcompletions.push(this.newSnippetCompletionItem({\n\t\t\t\tlabel: localize('derivedLabel', \"Files with Siblings by Name\"),\n\t\t\t\tdocumentation: localize('siblingsDescription', \"Match files that have siblings with the same name but a different extension.\"),\n\t\t\t\tsnippet: '{ \"when\": \"$(basename).${1:extension}\" }',\n\t\t\t\trange\n\t\t\t}));\n\t\t}\n\n\t\treturn Promise.resolve(completions);\n\t}\n\n\tprivate provideLanguageCompletionItems(_location: Location, range: vscode.Range, formatFunc: (string: string) => string = (l) => JSON.stringify(l)): Thenable<vscode.CompletionItem[]> {\n\t\treturn vscode.languages.getLanguages()\n\t\t\t.then(languages => languages.map(l => this.newSimpleCompletionItem(formatFunc(l), range)));\n\t}\n\n\tprivate provideLanguageCompletionItemsForLanguageOverrides(_location: Location, range: vscode.Range, formatFunc: (string: string) => string = (l) => JSON.stringify(l)): Thenable<vscode.CompletionItem[]> {\n\t\treturn vscode.languages.getLanguages().then(languages => {\n\t\t\tconst completionItems = [];\n\t\t\tconst configuration = vscode.workspace.getConfiguration();\n\t\t\tfor (const language of languages) {\n\t\t\t\tconst inspect = configuration.inspect(`[${language}]`);\n\t\t\t\tif (!inspect || !inspect.defaultValue) {\n\t\t\t\t\tconst item = new vscode.CompletionItem(formatFunc(language));\n\t\t\t\t\titem.kind = vscode.CompletionItemKind.Property;\n\t\t\t\t\titem.range = range;\n\t\t\t\t\tcompletionItems.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn completionItems;\n\t\t});\n\t}\n\n\tprivate provideLanguageOverridesCompletionItems(location: Location, position: vscode.Position): vscode.ProviderResult<vscode.CompletionItem[]> {\n\n\t\tif (location.path.length === 0) {\n\n\t\t\tlet range = this.document.getWordRangeAtPosition(position, /^\\s*\\[.*]?/) || new vscode.Range(position, position);\n\t\t\tlet text = this.document.getText(range);\n\t\t\tif (text && text.trim().startsWith('[')) {\n\t\t\t\trange = new vscode.Range(new vscode.Position(range.start.line, range.start.character + text.indexOf('[')), range.end);\n\t\t\t\treturn this.provideLanguageCompletionItemsForLanguageOverrides(location, range, language => `\"[${language}]\"`);\n\t\t\t}\n\n\t\t\trange = this.document.getWordRangeAtPosition(position) || new vscode.Range(position, position);\n\t\t\ttext = this.document.getText(range);\n\t\t\tlet snippet = '\"[${1:language}]\": {\\n\\t\"$0\"\\n}';\n\n\t\t\t// Suggestion model word matching includes quotes,\n\t\t\t// hence exclude the starting quote from the snippet and the range\n\t\t\t// ending quote gets replaced\n\t\t\tif (text && text.startsWith('\"')) {\n\t\t\t\trange = new vscode.Range(new vscode.Position(range.start.line, range.start.character + 1), range.end);\n\t\t\t\tsnippet = snippet.substring(1);\n\t\t\t}\n\n\t\t\treturn Promise.resolve([this.newSnippetCompletionItem({\n\t\t\t\tlabel: localize('languageSpecificEditorSettings', \"Language specific editor settings\"),\n\t\t\t\tdocumentation: localize('languageSpecificEditorSettingsDescription', \"Override editor settings for language\"),\n\t\t\t\tsnippet,\n\t\t\t\trange\n\t\t\t})]);\n\t\t}\n\n\t\tif (location.path.length === 1 && location.previousNode && typeof location.previousNode.value === 'string' && location.previousNode.value.startsWith('[')) {\n\t\t\t// Suggestion model word matching includes closed sqaure bracket and ending quote\n\t\t\t// Hence include them in the proposal to replace\n\t\t\tconst range = this.document.getWordRangeAtPosition(position) || new vscode.Range(position, position);\n\t\t\treturn this.provideLanguageCompletionItemsForLanguageOverrides(location, range, language => `\"[${language}]\"`);\n\t\t}\n\t\treturn Promise.resolve([]);\n\t}\n\n\tprivate newSimpleCompletionItem(text: string, range: vscode.Range, description?: string, insertText?: string): vscode.CompletionItem {\n\t\tconst item = new vscode.CompletionItem(text);\n\t\titem.kind = vscode.CompletionItemKind.Value;\n\t\titem.detail = description;\n\t\titem.insertText = insertText ? insertText : text;\n\t\titem.range = range;\n\t\treturn item;\n\t}\n\n\tprivate newSnippetCompletionItem(o: { label: string; documentation?: string; snippet: string; range: vscode.Range; }): vscode.CompletionItem {\n\t\tconst item = new vscode.CompletionItem(o.label);\n\t\titem.kind = vscode.CompletionItemKind.Value;\n\t\titem.documentation = o.documentation;\n\t\titem.insertText = new vscode.SnippetString(o.snippet);\n\t\titem.range = o.range;\n\t\treturn item;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as vscode from 'vscode';\nimport * as nls from 'vscode-nls';\nconst localize = nls.loadMessageBundle();\n\n\nexport function provideInstalledExtensionProposals(existing: string[], additionalText: string, range: vscode.Range, includeBuiltinExtensions: boolean): vscode.ProviderResult<vscode.CompletionItem[] | vscode.CompletionList> {\n\tif (Array.isArray(existing)) {\n\t\tconst extensions = includeBuiltinExtensions ? vscode.extensions.all : vscode.extensions.all.filter(e => !(e.id.startsWith('vscode.') || e.id === 'Microsoft.vscode-markdown'));\n\t\tconst knownExtensionProposals = extensions.filter(e => existing.indexOf(e.id) === -1);\n\t\tif (knownExtensionProposals.length) {\n\t\t\treturn knownExtensionProposals.map(e => {\n\t\t\t\tconst item = new vscode.CompletionItem(e.id);\n\t\t\t\tconst insertText = `\"${e.id}\"${additionalText}`;\n\t\t\t\titem.kind = vscode.CompletionItemKind.Value;\n\t\t\t\titem.insertText = insertText;\n\t\t\t\titem.range = range;\n\t\t\t\titem.filterText = insertText;\n\t\t\t\treturn item;\n\t\t\t});\n\t\t} else {\n\t\t\tconst example = new vscode.CompletionItem(localize('exampleExtension', \"Example\"));\n\t\t\texample.insertText = '\"vscode.csharp\"';\n\t\t\texample.kind = vscode.CompletionItemKind.Value;\n\t\t\texample.range = range;\n\t\t\treturn [example];\n\t\t}\n\t}\n\treturn undefined;\n}\n\n"],"sourceRoot":""}